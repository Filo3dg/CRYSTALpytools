.. image:: _static/CRYSTAL_logo.png
   :width: 200 px
   :alt: CRYSTALpytools
   :align: center

Introduction
============

The CRYSTALpytools python package contains functions that allow the user to access the `CRYSTAL code <https://www.crystal.unito.it/index.html>`_ input, output and execution from a python infrastructure, such as Jupyter Notebooks. Although they can achieve this goal on their own, they achieve their full potential when used together with `PyMatGen <https://pymatgen.org/index.html>`_. In this latter scenario, the CRYSTALpytools could be seen as a layer between CRYSTAL and pymatgen.

In January 2022 the first stable version (v2022.1.10) was released.

Installation
============

Create a conda/anaconda environment
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This step is not mandatory, but it makes using CRYSTALpytools very smooth. It is, therefore, very recommended. If you are new to anaconda, please follow `these steps <https://docs.conda.io/projects/conda/en/latest/user-guide/install/index.html>`_ to install it on your computer.

Create a new conda environment:

.. code-block:: console

   conda create --name crystal python=3.9

In the line above, ``crystal`` is the name of the environment and can be set to any you like. The ``python=3.9`` ensures that the suitable python distribution is installed.

Activate the conda environment:

.. code-block:: console

   conda activate crystal

Install CRYSTALpytools
~~~~~~~~~~~~~~~~~~~~~~

The CRYSTALpytools package can be installed from pip. Pip is a package-management system written in Python and is used to install and manage software packages (called modules in python).

.. code-block:: console

   pip install --upgrade CRYSTALpytools

Windows users might need to install windows-curses. This can be done by using:

.. code-block:: console

   pip install windows-curses

To check that CRYSTALpytools was installed successfully please type:

.. code-block:: console

   conda list | grep -i 'crystalpytools'

For Windows users, please use:

.. code-block:: console

   conda list | findstr /i crystalpytools

This will return to entries containing the text string 'crystalpytools' (case insensitive). Here there should be 'crystalpytools' with version number (e.g. '2023.4.4') and source ('pypi'). If this is not the case, something went wrong during the installation. Please check the location of the environment that is being displayed. This appears at the beginning of the “conda list” command. The most common mistake at this stage is that the environment was not activated as described above.

Please note that pip will only install the functions and not the example notebooks. This decision was taken in order to reduce the volume of data transferred when installing. If you are interested in the example notebooks please read the section below.

Set the path to runcry and runprop
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you intend to run CRYSTAL on the machine where you are running the CRYSTALpytools, the path to your local runcry and runprop needs to be specified. To do so, please run the set_runcry_path and set_runprop_path functions:

.. code-block:: console

   python 3
   >>> from CRYSTALpytools.execute import set_runcry_path, set_runprop_path
   >>>
   >>> set_runcry_path('path_to_your_runcry')
   >>> set_runprop_path('path_to_your_runcry')

Examples and Tutorials
======================

Each function is documented in Jupyter Notebooks that can be found in the `example folder <https://github.com/crystal-code-tools/CRYSTALpytools/tree/main/examples>`_. There is one notebook per function file (e.g. the functions contained in 'crystal_io.py' are explained in the 'examples/crystal_io.ipynb' notebook).

Tutorials can be found in the `tutorial folder <https://github.com/crystal-code-tools/CRYSTALpytools/tree/main/tutorial>`_.

Usage
=====

The CRYSTALpytools module aims at providing the user a python interface to the CRYSTAL code. The central data structure, called ``Crystal_object``, is created by the ``crystal_io`` by parsing CRYSTAL input/output files. The flowchart below is aimed at showing how different parts of the module interact with the ``Crystal_objects``.

.. figure:: _static/crystal_object.jpg
   :width: 600 px
   :alt: crystal_object
   :align: center

   The general structure of CRYSTALpytools

The following flowcharts cover a wide range of workflows where CRYSTALpytools can be used. In order to run the CRYSTAL calculation, input data needs to be written to file. Nonetheless, CRYSTALpytools offers a much more approach flexible to do so.

Despite trying to be as comprehensive as possible, these flowcharts will not cover all possible scenarios. Should you have any question please feel free to contact the maintainers of this repository.

Start from a pymatgen object
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. figure:: _static/pymatgen_start.png
   :width: 500 px
   :alt: pymatgen_start
   :align: center

   Starting a calculation from the Materials Project Database and Python in-line commands

This is the most flexible approach. Pymatgen gives the user the option to download structures from `the Materials Project database <https://pymatgen.org/pymatgen.ext.matproj.html?highlight=mprester#pymatgen.ext.matproj.MPRester>`_. 

Start from CRYSTAL input file or manually prepare the input
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. figure:: _static/crystal_start.png
   :width: 550 px
   :alt: crystal_start
   :align: center

   Staring a calculation from the CRYSTAL input file (d12/d3)

In some instances, for example when studying a material for which you already have an input file, it might be easier to create a Crystal_input object by reading the information from file. Some researchers might find it easier to manually prepare the input. This means that the input lines are specified as lists in python and then written to file using the ``write_crystal_input`` function.

Output analysis only
~~~~~~~~~~~~~~~~~~~~

.. figure:: _static/output_analysis.png
   :width: 450 px
   :alt: output_analysis
   :align: center

   The Post-processing of CRYSTAL output files

This case applied to when the calculations were run on a different machine and the user might be interested in analysing the output. The inputs can be generated from any of the two workflows above by stopping before execution.

The functions are divided into files depending on their ultimate goal. For example, all the i/o functions are saved in 'CRYSTALpytools/crystal_io.py'. To access them, please use:

.. code-block:: python

   >>> from CRYSTALpytools.crystal_io import Crystal_output
   >>>
   >>> Crystal_output().read_cry_output('output_name.out')

Each individual function contains either 'crystal' or 'cry' in its name. This was chosen, despite making the names of the functions longer, in order to avoid ambiguity. This means that when calling a function, you will know that it refers to a CRYSTALpytools function and not, for example, a pymatgen one with a similar name.

Testing
=======

To test the CRYSTALpytools please run the test notebook that can be found in the `unit_test folder <https://github.com/crystal-code-tools/CRYSTALpytools/tree/main/unit_test>`_. Alternatively, please run the following command:

.. code-block:: python

   >>> from CRYSTALpytools.unit_test import *
   >>>
   >>> test_all('./data_test/')

where ``./data_test/`` is the path to the test folder.

All values should return True if the test is passed.
